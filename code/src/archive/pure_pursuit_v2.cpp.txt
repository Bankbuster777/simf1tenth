#include <ros/ros.h>
#include <vector>
#include <iostream>
#include <fstream> 
#include <string>
#include <geometry_msgs/PoseStamped.h>
#include <sensor_msgs/LaserScan.h>
#include <tf/tf.h>
#include <tf/transform_listener.h>
#include <geometry_msgs/TransformStamped.h>
#include <math.h>
// TODO: include ROS msg type headers and libraries you need
    // Subscriber
#include <nav_msgs/Odometry.h>
    // Publisher
#include <visualization_msgs/Marker.h>
#include <visualization_msgs/MarkerArray.h>
#include "ackermann_msgs/AckermannDrive.h"
#include "ackermann_msgs/AckermannDriveStamped.h"

class PurePursuit {
private:
    ros::NodeHandle n;
    // TODO: create ROS subscribers and publishers
        // Subscriber
    ros::Subscriber particle_sub;

        // Puslisher
    ros::Publisher pure_drive_pub;
    // ros::Publisher curr_marker_pub;
    // ros::Publisher wplist_marker_pub;

    std::string file_path = "/home/dawgs/dawgs_car/sim_f1tenth_ws/src/labs_f1tenth/lab6/waypoints/";
    double wheelbase, max_steering_angle, drive_speed;

    double dist_thres = 1.0;
    int wp_iter =0;
    geometry_msgs::PoseStamped curr_wp_pose;
    std::vector<geometry_msgs::PoseStamped> vec_waypoints;

    // Transform
    tf::TransformListener listener;
    tf::StampedTransform map_to_base_link_tf;
    std::string err;

public:
    PurePursuit() {
        n = ros::NodeHandle("~");

        // get topic names
        std::string pf_pose_topic, curr_marker_topic, wp_list_marker_topic, pure_drive_topic;
        n.getParam("pf_pose_topic", pf_pose_topic);
        n.getParam("curr_marker_topic", curr_marker_topic);
        n.getParam("wp_list_marker_topic", wp_list_marker_topic);
        n.getParam("pure_drive_topic", pure_drive_topic);

        // get car parameters
        n.getParam("wheelbase", wheelbase);
        n.getParam("max_steering_angle", max_steering_angle);
        n.param("drive_speed", drive_speed, 1.0);

        std::string map_frame, base_frame, scan_frame;
        n.getParam("map_frame", map_frame);
        n.getParam("base_frame", base_frame);
        n.getParam("scan_frame", scan_frame);

        std::string wp_csv ="waypoints_240121";
        read_waypoints(wp_csv, vec_waypoints);
        // comments out for segmentation failure
        curr_wp_pose.pose.position.x = vec_waypoints[wp_iter].pose.position.x;
        curr_wp_pose.pose.position.y = vec_waypoints[wp_iter].pose.position.y;

        listener.waitForTransform(base_frame, map_frame, ros::Time(0), ros::Duration(3.0));
        if (listener.canTransform(base_frame, map_frame, ros::Time(0), &err)){
            listener.lookupTransform(base_frame, map_frame, ros::Time(0), map_to_base_link_tf);
            ROS_INFO("Transform done");
        }
        else{
            ROS_INFO_STREAM("Cannot transform: " << err);
        }

        // TODO: create ROS subscribers and publishers
        // SubScriber
        particle_sub = n.subscribe(pf_pose_topic, 1, &PurePursuit::pose_callback, this);

        // Publisher
        pure_drive_pub = n.advertise<ackermann_msgs::AckermannDriveStamped>(pure_drive_topic, 10);
        // curr_marker_pub = n.advertise<visualization_msgs::Marker>(curr_marker_topic, 1);
        // wplist_marker_pub = n.advertise<visualization_msgs::MarkerArray>(wp_list_marker_topic, 1);

        ROS_INFO("Initial done");
    }

    void read_waypoints(std::string csv_file, std::vector<geometry_msgs::PoseStamped>& v_waypoints){
        std::fstream csv_wp;
        std::string x_str, y_str, file_name;
        geometry_msgs::PoseStamped single_waypoint;
        single_waypoint.header.frame_id = "map";
        file_name = file_path + csv_file + ".csv";
        
        csv_wp.open(file_name, std::ios::in);
        if(!csv_wp.is_open()){
            ROS_INFO("Cannot open the file : %s", csv_file);
        }
        else{
            while(!csv_wp.eof()){                
                std::getline(csv_wp, x_str, ',');
                std::getline(csv_wp, y_str, '\n');
                if(!x_str.empty()){
                    single_waypoint.pose.position.x = std::stof(x_str);
                    single_waypoint.pose.position.y = std::stof(y_str);
                    v_waypoints.push_back(single_waypoint);
                }
            }
            ROS_INFO("Read csv done");
            ROS_INFO("First : %f %f", v_waypoints.front().pose.position.x, v_waypoints.front().pose.position.y);
            ROS_INFO("N of wp: %d", v_waypoints.size());
            csv_wp.close();
        }
    }

    void pose_callback(const nav_msgs::Odometry &pose_msg) {
        // TODO: find the current waypoint to track using methods mentioned in lecture
        // visualization_msgs::Marker curr_wp_marker, wp_marker; 

        geometry_msgs::PoseStamped transformed_wp_pose;
        float pos_x, pos_y, pos_theta;
        pos_x     = pose_msg.pose.pose.position.x;
        pos_y     = pose_msg.pose.pose.position.y;
        pos_theta = pose_msg.pose.pose.orientation.z;
        
        float lookup_dist, lateral_dist, target_steering_angle, turning_radius, curvature, dist, dist_err_sq, dist_transformed_sq; 

        // TODO: transform goal point to vehicle frame of reference
        dist_err_sq = (pos_x - curr_wp_pose.pose.position.x) * (pos_x - curr_wp_pose.pose.position.x) +
                      (pos_y - curr_wp_pose.pose.position.y) * (pos_y - curr_wp_pose.pose.position.y);
        dist = sqrt(dist_err_sq);
        ROS_INFO("Dist2Wp: %f", dist);
        
        if(dist_err_sq < dist_thres){
            wp_iter += 1;
            curr_wp_pose.pose.position.x = vec_waypoints[wp_iter].pose.position.x;
            curr_wp_pose.pose.position.y = vec_waypoints[wp_iter].pose.position.y;
            ROS_INFO("iter: %d", wp_iter);
        }
        listener.transformPose("base_link", curr_wp_pose, transformed_wp_pose);
        

        // TODO: calculate curvature/steering angle
        lookup_dist = transformed_wp_pose.pose.position.x * transformed_wp_pose.pose.position.x +
                      transformed_wp_pose.pose.position.y * transformed_wp_pose.pose.position.y;
        lateral_dist = transformed_wp_pose.pose.position.x;
        turning_radius = (lookup_dist*lookup_dist)/(2 * abs(lateral_dist));
        target_steering_angle = atan2(wheelbase, turning_radius);

        // don't forget to limit the steering angle between -0.4189 and 0.4189 radians
        if(target_steering_angle > max_steering_angle){
            ROS_INFO("too much + steering %f", target_steering_angle);
            target_steering_angle = max_steering_angle;
        }
        else if(target_steering_angle < - max_steering_angle){
            ROS_INFO("too much - steering %f", target_steering_angle);
            target_steering_angle = -1 * max_steering_angle;
        }

        // TODO: publish drive message
        ackermann_msgs::AckermannDriveStamped drive_st_msg;
        ackermann_msgs::AckermannDrive drive_msg;
        drive_msg.steering_angle = target_steering_angle;
        drive_msg.speed = drive_speed;
        drive_st_msg.drive = drive_msg;
                
        pure_drive_pub.publish(drive_st_msg);

    }
};
int main(int argc, char ** argv) {
    ros::init(argc, argv, "pure_pursuit");
    PurePursuit pp;
    ros::spin();
    return 0;
}