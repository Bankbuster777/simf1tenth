#include <ros/ros.h>
#include <vector>
#include <iostream>
#include <fstream> 
#include <string>
#include <geometry_msgs/PoseStamped.h>
#include <sensor_msgs/LaserScan.h>
#include <tf2_geometry_msgs/tf2_geometry_msgs.h>
#include <tf2_ros/transform_listener.h>
#include <tf/transform_listener.h>
#include <geometry_msgs/TransformStamped.h>
#include <math.h>
// TODO: include ROS msg type headers and libraries you need
    // Subscriber
#include <nav_msgs/Odometry.h>
    // Publisher
#include <visualization_msgs/Marker.h>
#include <visualization_msgs/MarkerArray.h>
#include "ackermann_msgs/AckermannDrive.h"
#include "ackermann_msgs/AckermannDriveStamped.h"

class PurePursuit {
private:
    ros::NodeHandle n;
    // TODO: create ROS subscribers and publishers
        // Subscriber
    ros::Subscriber particle_sub;

        // Puslisher
    ros::Publisher pure_drive_pub;
    ros::Publisher curr_marker_pub;
    ros::Publisher wplist_marker_pub;

    std::string file_path = "/home/dawgs/dawgs_car/sim_f1tenth_ws/src/labs_f1tenth/lab6/waypoints/";
    geometry_msgs::TransformStamped map_to_base_link;
    double wheelbase, max_steering_angle, drive_speed;

    double dist_thres = 1.0;
    int wp_iter =0;
    geometry_msgs::PoseStamped curr_wp_pose;
    std::vector<geometry_msgs::PoseStamped> vec_waypoints;

    tf::TransformListener listener;
    

public:
    PurePursuit() {
        n = ros::NodeHandle("~");

        // get topic names
        std::string pf_pose_topic, curr_marker_topic, wp_list_marker_topic, pure_drive_topic;
        n.getParam("pf_pose_topic", pf_pose_topic);
        n.getParam("curr_marker_topic", curr_marker_topic);
        n.getParam("wp_list_marker_topic", wp_list_marker_topic);
        n.getParam("pure_drive_topic", pure_drive_topic);

        // get car parameters
        n.getParam("wheelbase", wheelbase);
        n.getParam("max_steering_angle", max_steering_angle);
        n.param("drive_speed", drive_speed, 1.0);

        std::string wp_csv ="waypoints_240121";
        read_waypoints(wp_csv, vec_waypoints);
        // comments out for segmentation failure
        curr_wp_pose.pose.position.x = vec_waypoints[wp_iter].pose.position.x;
        curr_wp_pose.pose.position.y = vec_waypoints[wp_iter].pose.position.y;

        //tf version
        if (listener.canTransform("/base_link","/map", ros::Time(0))){
            listener.lookupTransform("/base_link", "/map", ros::Time(0), map_to_base_link_tf);
            ROS_INFO("Transform done");
        }
        else{
            ROS_INFO("Cannot transform");
        }

        tf2_ros::Buffer tf2_buffer;
        tf2_ros::TransformListener tf2_listener(tf2_buffer);
        if (tf2_buffer.canTransform("map","base_link", ros::Time(0), ros::Duration(0.01))){
            map_to_base_link = tf2_buffer.lookupTransform("map", "base_link", ros::Time(0));
            ROS_INFO("Transform done");
        }
        else{
            ROS_INFO("Cannot transform");
        }

        // TODO: create ROS subscribers and publishers
        // SubScriber
        particle_sub = n.subscribe(pf_pose_topic, 10, &PurePursuit::pose_callback, this);

        // Publisher
        // curr_marker_pub = n.advertise<visualization_msgs::Marker>(curr_marker_topic, 1);
        // wplist_marker_pub = n.advertise<visualization_msgs::MarkerArray>(wp_list_marker_topic, 1);
        pure_drive_pub = n.advertise<ackermann_msgs::AckermannDriveStamped>(pure_drive_topic, 1);

        ROS_INFO("Initial done");
    }

    void read_waypoints(std::string csv_file, std::vector<geometry_msgs::PoseStamped>& v_waypoints){
        std::fstream csv_wp;
        std::string x_str, y_str, file_name;
        geometry_msgs::PoseStamped single_waypoint;
        single_waypoint.header.frame_id = "map";
        file_name = file_path + csv_file + ".csv";
        
        csv_wp.open(file_name, std::ios::in);
        if(!csv_wp.is_open()){
            ROS_INFO("Cannot open the file : %s", csv_file);
        }
        else{
            while(!csv_wp.eof()){                
                std::getline(csv_wp, x_str, ',');
                std::getline(csv_wp, y_str, '\n');
                if(!x_str.empty()){
                    single_waypoint.pose.position.x = std::stod(x_str);
                    single_waypoint.pose.position.y = std::stod(y_str);
                    v_waypoints.push_back(single_waypoint);
                }
            }
            ROS_INFO("Read csv done");
            csv_wp.close();
        }
    }

    void pose_callback(const geometry_msgs::PoseStamped::ConstPtr &pose_msg) {
        // TODO: find the current waypoint to track using methods mentioned in lecture
        visualization_msgs::Marker curr_wp_marker, wp_marker; 

        std::vector<float> curr_wp;
        geometry_msgs::PoseStamped curr_wp_pose, transformed_wp_pose;
        float pos_x, pos_y, pos_theta;
        pos_x     = pose_msg -> pose.position.x;
        pos_y     = pose_msg -> pose.position.y;
        pos_theta = pose_msg -> pose.orientation.z;

        float lookup_dist, lateral_dist, target_steering_angle, turning_radius, curvature, dist, dist_err_sq, dist_transformed_sq; 
        dist_err_sq = (pos_x - curr_wp_pose.pose.position.x) * (pos_x - curr_wp_pose.pose.position.x) +
                      (pos_y - curr_wp_pose.pose.position.y) * (pos_y - curr_wp_pose.pose.position.y);
        dist = sqrt(dist_err_sq);
        
        if(dist_err_sq < dist_thres){
            wp_iter += 1;
            curr_wp_pose.pose.position.x = vec_waypoints[wp_iter].pose.position.x;
            curr_wp_pose.pose.position.y = vec_waypoints[wp_iter].pose.position.y;
        }

        // TODO: transform goal point to vehicle frame of reference
        tf2::doTransform(curr_wp_pose, transformed_wp_pose, map_to_base_link);
        dist_transformed_sq = transformed_wp_pose.pose.position.x * transformed_wp_pose.pose.position.x + 
                              transformed_wp_pose.pose.position.y * transformed_wp_pose.pose.position.y;
        ROS_INFO("dist %f", dist_transformed_sq);

        // TODO: calculate curvature/steering angle
        turning_radius = (lookup_dist*lookup_dist)/(2 * abs(lateral_dist));
        target_steering_angle = atan2(wheelbase, turning_radius);

        if(target_steering_angle > max_steering_angle){
            ROS_INFO("too much + steering %f", target_steering_angle);
            target_steering_angle = max_steering_angle;
        }
        else if(target_steering_angle < - max_steering_angle){
            ROS_INFO("too much - steering %f", target_steering_angle);
            target_steering_angle = -1* max_steering_angle;
        }

        // TODO: publish drive message, don't forget to limit the steering angle between -0.4189 and 0.4189 radians
        // initialize message to be published
        ackermann_msgs::AckermannDriveStamped drive_st_msg;
        ackermann_msgs::AckermannDrive drive_msg;
        drive_msg.steering_angle = target_steering_angle;
        drive_msg.speed = drive_speed; // constant_speed
        drive_st_msg.drive = drive_msg;
                
        pure_drive_pub.publish(drive_st_msg);


    }

};
int main(int argc, char ** argv) {
    ros::init(argc, argv, "pure_pursuit_node");
    PurePursuit pp;
    ros::spin();
    return 0;
}